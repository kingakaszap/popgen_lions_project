// 1. 
////////////////////////////////////////////////////
//	1. Initialise everything //////////////////
//////////////////////////////////////////////////// 
initialize() {
	if (exists("slimgui")) {
		// Carrying capacities
		defineConstant("KGSE_3", 5000);
		defineConstant("KGSE_4", 5000);
		defineConstant("KGSE_6", 2000);
		
		defineConstant("KC_0", 100);
		defineConstant("KC_1", 80);
		defineConstant("KC_2", 15);
		defineConstant("KC_2a", 30);
		defineConstant("KC_3", 50);
		defineConstant("KC_4", 100);
		defineConstant("KC_5", 120);
		defineConstant("KC_6", 50);
		defineConstant("KC_7", 100);
		
		defineConstant("M", 0);
	}
	
	initializeSLiMModelType("nonWF");
	initializeSex("A");
	defineConstant("geneLength", 1750);
	initializeMutationRate(5e-9);
	
	// Dominance coefficients
	defineConstant("h_VstrDel", 0.0);
	defineConstant("h_strDel", 0.01);
	defineConstant("h_modDel", 0.1);
	defineConstant("h_wkDel", 0.4);
	defineConstant("sampleSize", 10);
	defineConstant("Out", "C:/Users/Kinga/OneDrive - University of Edinburgh/Desktop/popgen/" + "new_populations" + "M=" + M + "_KF=" + KC_7 + "_" + getSeed() + ".csv");
	
	// dont forget to change this to my own filepath
	
	// Mutation types
	initializeMutationType("m1", h_VstrDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x >= -0.1); return x;");
	m1.convertToSubstitution = F;
	initializeMutationType("m2", h_strDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.1 | x >= -0.01); return x;");
	m2.convertToSubstitution = F;
	initializeMutationType("m3", h_modDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.01 | x >= -0.001); return x;");
	m3.convertToSubstitution = F;
	initializeMutationType("m4", h_wkDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.001); return x;");
	m4.convertToSubstitution = F;
	initializeMutationType("m5", 0.0,"f",-1.0);
	m5.convertToSubstitution = F;
	initializeMutationType("m6", 0.5,"f",0.0);
	m6.convertToSubstitution = T;
	
	// Genomic elements
	initializeGenomicElementType("g1", c(m1,m2,m3,m4,m5,m6), c(2.6,23.6,24.7,49.1,0.5,43.3));
	gene_vec = c(500,500,500,500,500,500,500,500,500,500);
	defineConstant("seqLength", sum(gene_vec)*geneLength);
	gene_num = sum(gene_vec);
	
	for (i in 1:gene_num) {
		initializeGenomicElement(g1, ((i-1)*geneLength)+(i-1), (i*geneLength)+(i-2));
	}
	
	// Recombination rates
	rates = NULL;
	for (i in 1:(size(gene_vec)-1)) {
		rates = c(rates, 0, rep(c(1e-3,0), asInteger(gene_vec[i-1]-1)), 0.5);
	}
	rates = c(rates, 0, rep(c(1e-3,0), asInteger(gene_vec[size(gene_vec)-1]-1)));
	
	ends = NULL;
	for (i in 1:gene_num) {
		ends = c(ends, (i*geneLength)+(i-2), (i*geneLength)+(i-1));
	}
	ends = ends[0:(size(ends)-2)];
	
	initializeRecombinationRate(rates, ends);
}

////////////////////////////////////////////////////
//	2. Import burnin population //////////////////
////////////////////////////////////////////////////
1 early() {
	sim.readFromPopulationFile("C:\\Users\\Kinga\\OneDrive - University of Edinburgh\\Desktop\\text_file_GSE_simulation_snapshot_55600.txt");
}

////////////////////////////////////////////////////
//	3. reproduction for GSE //////////////////
////////////////////////////////////////////////////

reproduction(p1) {
	if (sim.cycle % 2 == 0){ //reproduction every 2 years - seems to reduce poppulation size by a lot
		// get males and females and randomize their order
		matureMales = subpop.sampleIndividuals(asInteger(sum(subpop.individuals.sex == "M")*0.69), sex="M", minAge=4,maxAge=10);
		matureMales_mating_twice=sample(matureMales,asInteger(length(matureMales)*0.6));
		males=c(matureMales,matureMales_mating_twice);
		//males = sample(males, size(males), replace=F);
		//cat(sim.cycle + "," + "males=" + size(males)+ "\n");
		
		females = subpop.subsetIndividuals(sex="F", minAge=3,maxAge=14);
		females = sample(females, size(females), replace=F);
		//cat(sim.cycle + "," + "females=" + size(males)+ "\n");
		
		femaleCount = size(females);
		// draw number of offspring for males, assuming dominance
		offspringCounts = sample(1:3, size(males), replace=T, weights=c(0.2,0.2,0.6));
		// go through the males until we run out of females
		nextFemaleIndex = 0;
		males.tag = 0;
		for (maleIndex in seqAlong(males))
		{
			male = males[maleIndex];
			offspringCount = offspringCounts[maleIndex];
			
			//catn("male offspring number: " + paste(males.tag));
			for (i in seqLen(offspringCount))
			{
				if (nextFemaleIndex < femaleCount)
				{
					offspring = subpop.addCrossed(females[nextFemaleIndex], male,sex = 0.5);
					nextFemaleIndex = nextFemaleIndex + 1;
					male.tag = male.tag + 1;
				}
				else
				{
					// disable this callback for this cycle
					self.active = 0;
					return;
				}
			}
		}
	}
	// disable this callback for this cycle
	self.active = 0;
}
////////////////////////////////////////////////////
//	4. Try to do fitnesss scaling for pops //////////////////
////////////////////////////////////////////////////

2 early() {
	// list subpops that exist at a given point
	subpops = c();
	if (exists("p1")) subpops = c(subpops, p1);
	if (exists("p2")) subpops = c(subpops, p2);
	for (s in subpops) {
		inds = s.individuals;
		// skip empty subpops
		if (size(inds) == 0) {
			s.fitnessScaling = 1.0; // fallback
			continue;
		}
		
		// age and sex specific survival
		//0.01 for females, no info on males; 0.05 to be conservative
		L_F= c(0.5,0.2,0.05,0.05,0.15,0.15,0.15,0.15,0.15,0.15,0.4,0.4,0.4,0.4,1);
		L_M= c(0.5,0.4,0.2,0.2,0.3,0.3,0.3,0.3,0.3,0.3,0.4,0.4,0.4,0.4,1);
		
		ages = inds.age;
		//		mortality = L_F[ages];
		//		survival = 1 - mortality;
		//		inds.fitnessScaling = survival;
		
		m=(inds.sex=="M");
		f=(inds.sex=="F");
		
		ages_m = ages[m];
		ages_f = ages[f];
		
		mortality_m = L_M[ages_m];
		mortality_f = L_F[ages_f];
		
		//calculate survival based on age
		survival_m = 1 - mortality_m;
		survival_f = 1 - mortality_f;
		
		//rescale fitness based on age-survival
		inds[m].fitnessScaling = survival_m;
		inds[f].fitnessScaling = survival_f;
		
		p1.setValue("K", 2000);
		K = s.getValue("K");
		inds_m = s.individuals[m];
		inds_f = s.individuals[f];
		
		s.fitnessScaling = K /(s.individualCount * mean(c(survival_m, survival_f))); //works
		
		s.individuals.tagF = inds.fitnessScaling*s.fitnessScaling;
	}
}

////////////////////////////////////////////////////
//	5. Make crater pop  events //////////////////
////////////////////////////////////////////////////
55601 late() {
	sim.addSubpop("p2", 0).setValue("K", 100);
	migrants_F = p1.sampleIndividuals(50, sex="F", minAge=2, maxAge=10);
	migrants_M = p1.sampleIndividuals(50, sex="M", minAge=2, maxAge=10);
	p2.takeMigrants(c(migrants_F, migrants_M));
	print("cycle number:" + sim.cycle + " Crater pop. created");
}

// Crater K updates -- ajust based on when burnin ends
55731 late() { p2.setValue("K", KC_1); catn("Crater 1950: " + p2.individualCount); }
55743 late() { p2.setValue("K", KC_2); catn("Crater 1962: " + p2.individualCount); }
55745 late() { p2.takeMigrants(p1.sampleIndividuals(4, sex="M", minAge=4, maxAge=10)); }
55746 late() { p2.setValue("K", KC_2a); p2.takeMigrants(p1.sampleIndividuals(3, sex="M", minAge=4, maxAge=10)); }
55749 late() { p2.setValue("K", KC_3); }
55760 late() { p2.setValue("K", KC_4); catn("Crater 1979: " + p2.individualCount); }
55762 late() { p2.setValue("K", KC_5); catn("Crater 1981: " + p2.individualCount); }
55774 late() { p2.takeMigrants(p1.sampleIndividuals(1, sex="M", minAge=4, maxAge=10)); catn("Crater 1993: " + p2.individualCount); }
55781 late() { p2.setValue("K", KC_6); catn("Crater 2000: " + p2.individualCount); }
55794 late() { p2.takeMigrants(p1.sampleIndividuals(4, sex="M", minAge=4, maxAge=10)); catn("Crater 2013: " + p2.individualCount); }
55796 late() { p2.takeMigrants(p1.sampleIndividuals(1, sex="M", minAge=4, maxAge=10)); }
55799 late() { p2.takeMigrants(p1.sampleIndividuals(2, sex="M", minAge=4, maxAge=10)); }
55801 late() { p2.setValue("K", KC_6); }
55802 late() { p2.setValue("K", KC_7); catn("Crater 2021: " + p2.individualCount); }

////////////////////////////////////////////////////
//	5. reproduction for crater //////////////////
////////////////////////////////////////////////////
reproduction(p2) {
	if (sim.cycle % 2 == 0){
		// get males and females and randomize their order
		matureMales = subpop.sampleIndividuals(asInteger(sum(subpop.individuals.sex == "M")*0.78), sex="M", minAge=4,maxAge=10);
		matureMales_mating_twice=sample(matureMales,asInteger(length(matureMales)*0.6));
		migrantMales = subpop.sampleIndividuals(subpop.individuals.size(), sex="M", minAge=2,maxAge=9,migrant=T);
		males=c(matureMales,matureMales_mating_twice,migrantMales);
		//cat(sim.cycle + "," + "males=" + size(males)+ "\n");
		
		matureFemales = subpop.subsetIndividuals(sex="F", minAge=3,maxAge=14);
		females=c(matureFemales);
		//cat(sim.cycle + "," + "females=" + size(males)+ "\n");
		
		femaleCount = size(females);
		// draw number of offspring for males, assuming dominance
		offspringCounts = sample(1:3, size(males), replace=T, weights=c(0.2,0.2,0.6));
		// go through the males until we run out of females
		nextFemaleIndex = 0;
		males.tag = 0;
		for (maleIndex in seqAlong(males))
		{
			male = males[maleIndex];
			offspringCount = offspringCounts[maleIndex];
			
			//catn("male offspring number: " + paste(males.tag));
			//seems like it assumes that a female produces 1 offspring (it loops over offspringcount)
			for (i in seqLen(offspringCount))
			{
				if (nextFemaleIndex < femaleCount)
				{
					offspring = subpop.addCrossed(females[nextFemaleIndex], male,sex = 0.5);
					nextFemaleIndex = nextFemaleIndex + 1;
					male.tag = male.tag + 1;
				}
				else
				{
					// disable this callback for this cycle
					self.active = 0;
					return;
				}
			}
		}
	}
	// disable this callback for this cycle
	self.active = 0;
}


////////////////////////////////////////////////////
//	7. Zoo population with high fitness scaling //////////////////
////////////////////////////////////////////////////
55691 late() {
	sim.addSubpop("p3", 0).setValue("K", 50);
	migrants_F_zoo = p1.sampleIndividuals(5, sex="F", minAge=2);
	migrants_M_zoo = p1.sampleIndividuals(5, sex="M", minAge=2);
	p3.takeMigrants(c(migrants_F_zoo, migrants_M_zoo));
	print("cycle number:" + sim.cycle + " zoo population created");
	catn("zoo 1920: " + p3.individualCount);
}

early() {
	if (exists("p3")) {
		K_current = p3.getValue("K");
		N_current = max(p3.individualCount, 1); // avoid division by zero
		p3.fitnessScaling = 1.5 * K_current / N_current; // 1.5 = 50% extra survival
	}
}

// reproduction in zoo
reproduction(p3) {
	matureFemales = p3.subsetIndividuals(sex="F", minAge=2, maxAge=15);
	matureMales   = p3.subsetIndividuals(sex="M", minAge=2, maxAge=15);
	
	for (female in matureFemales) {
		if (size(matureMales) > 0) {
			father = sample(matureMales, 1);
			nOffspring = sample(1:3, 1, replace=T);
			for (i in seqLen(nOffspring)) {
				p3.addCrossed(female, father, sex=0.5);
			}
		}
	}
}



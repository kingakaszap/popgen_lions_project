// 1. Create the GSE
// 2. Simulate the split in the Crater
// 3. Simulate the split in the Zoo

// Import the neccesary data and initialize neccesary elements 

initialize() {
	if (exists("slimgui")) {
	   setSeed (SEED);
		initializeSLiMModelType("nonWF");
		initializeSex("A");
		defineConstant("geneLength", 1750);
		initializeMutationRate(5e-9);
		
		// Dominance coefficients
		defineConstant("h_VstrDel", 0.0);
		defineConstant("h_strDel", 0.01);
		defineConstant("h_modDel", 0.1);
		defineConstant("h_wkDel", 0.4);
		defineConstant("sampleSize", 10);
		
		defineConstant("M");
		defineConstant("KC_7");
		defineConstant("burnin_id");
	}
	
	// Mutation types
	initializeMutationType("m1", h_VstrDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x >= -0.1); return x;");
	m1.convertToSubstitution = F;
	initializeMutationType("m2", h_strDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.1 | x >= -0.01); return x;");
	m2.convertToSubstitution = F;
	initializeMutationType("m3", h_modDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.01 | x >= -0.001); return x;");
	m3.convertToSubstitution = F;
	initializeMutationType("m4", h_wkDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.001); return x;");
	m4.convertToSubstitution = F;
	initializeMutationType("m5", 0.0,"f",-1.0);
	m5.convertToSubstitution = F;
	initializeMutationType("m6", 0.5,"f",0.0);
	m6.convertToSubstitution = T;
	
	// Genomic elements
	initializeGenomicElementType("g1", c(m1,m2,m3,m4,m5,m6), c(2.6,23.6,24.7,49.1,0.5,43.3));
	gene_vec = c(500,500,500,500,500,500,500,500,500,500);
	defineConstant("seqLength", sum(gene_vec)*geneLength);
	gene_num = sum(gene_vec);
	
	for (i in 1:gene_num) {
		initializeGenomicElement(g1, ((i-1)*geneLength)+(i-1), (i*geneLength)+(i-2));}
	
	// Recombination rates
	rates = NULL;
	for (i in 1:(size(gene_vec)-1)) {
		rates = c(rates, 0, rep(c(1e-3,0), asInteger(gene_vec[i-1]-1)), 0.5);}
	rates = c(rates, 0, rep(c(1e-3,0), asInteger(gene_vec[size(gene_vec)-1]-1)));
	
	ends = NULL;
	for (i in 1:gene_num) {
		ends = c(ends, (i*geneLength)+(i-2), (i*geneLength)+(i-1));}
	ends = ends[0:(size(ends)-2)];
	
	initializeRecombinationRate(rates, ends);
	
	// for csv file with population statistics
	defineConstant("Out", "C:/Users/rosin/Desktop/popgen/Crater_GSE_forward/" + "new_populations" + "M=" + M + "_KF=" + KC_7 + "_" + getSeed() + ".csv");

}


////////////////////////////////////////////////////
//	3. reproduction for GSE //////////////////
////////////////////////////////////////////////////

reproduction(p1) {
	if (sim.cycle % 2 == 0){ //reproduction every 2 years - seems to reduce poppulation size by a lot
		// get males and females and randomize their order
		matureMales = subpop.sampleIndividuals(asInteger(sum(subpop.individuals.sex == "M")*0.69), sex="M", minAge=4,maxAge=10);
		matureMales_mating_twice=sample(matureMales,asInteger(length(matureMales)*0.6));
		males=c(matureMales,matureMales_mating_twice);
		//males = sample(males, size(males), replace=F);
		//cat(sim.cycle + "," + "males=" + size(males)+ "\n");
		
		females = subpop.subsetIndividuals(sex="F", minAge=3,maxAge=14);
		females = sample(females, size(females), replace=F);
		//cat(sim.cycle + "," + "females=" + size(males)+ "\n");
		
		femaleCount = size(females);
		// draw number of offspring for males, assuming dominance
		offspringCounts = sample(1:3, size(males), replace=T, weights=c(0.2,0.2,0.6));
		// go through the males until we run out of females
		nextFemaleIndex = 0;
		males.tag = 0;
		for (maleIndex in seqAlong(males))
		{
			male = males[maleIndex];
			offspringCount = offspringCounts[maleIndex];
			
			//catn("male offspring number: " + paste(males.tag));
			for (i in seqLen(offspringCount))
			{
				if (nextFemaleIndex < femaleCount)
				{
					offspring = subpop.addCrossed(females[nextFemaleIndex], male,sex = 0.5);
					nextFemaleIndex = nextFemaleIndex + 1;
					male.tag = male.tag + 1;
				}
				else
				{
					// disable this callback for this cycle
					self.active = 0;
					return;
				}}}}
	// disable this callback for this cycle
	self.active = 0;}


////////////////////////////////////////////////////
//	Reproduction for crater //////////////////
////////////////////////////////////////////////////
reproduction(p2) {
	if (sim.cycle % 2 == 0){
		// get males and females and randomize their order
		matureMales = subpop.sampleIndividuals(asInteger(sum(subpop.individuals.sex == "M")*0.78), sex="M", minAge=4,maxAge=10);
		matureMales_mating_twice=sample(matureMales,asInteger(length(matureMales)*0.6));
		migrantMales = subpop.sampleIndividuals(subpop.individuals.size(), sex="M", minAge=2,maxAge=9,migrant=T);
		males=c(matureMales,matureMales_mating_twice,migrantMales);
		//cat(sim.cycle + "," + "males=" + size(males)+ "\n");
		
		matureFemales = subpop.subsetIndividuals(sex="F", minAge=3,maxAge=14);
		females=c(matureFemales);
		//cat(sim.cycle + "," + "females=" + size(males)+ "\n");
		
		femaleCount = size(females);
		// draw number of offspring for males, assuming dominance
		offspringCounts = sample(1:3, size(males), replace=T, weights=c(0.2,0.2,0.6));
		// go through the males until we run out of females
		nextFemaleIndex = 0;
		males.tag = 0;
		for (maleIndex in seqAlong(males))
		{
			male = males[maleIndex];
			offspringCount = offspringCounts[maleIndex];
			
			//catn("male offspring number: " + paste(males.tag));
			//seems like it assumes that a female produces 1 offspring (it loops over offspringcount)
			for (i in seqLen(offspringCount))
			{
				if (nextFemaleIndex < femaleCount)
				{
					offspring = subpop.addCrossed(females[nextFemaleIndex], male,sex = 0.5);
					nextFemaleIndex = nextFemaleIndex + 1;
					male.tag = male.tag + 1;
				}
				else
				{
					// disable this callback for this cycle
					self.active = 0;
					return;
				}}}}
	// disable this callback for this cycle
	self.active = 0;}
	
	
//// REPRODUCTION FOR ZOO////////
////////////////////////////////
// reproduction in zoo

reproduction(p3) {
	matureFemales = p3.subsetIndividuals(sex="F", minAge=2, maxAge=15);
	matureMales   = p3.subsetIndividuals(sex="M", minAge=2, maxAge=15);
	
	// can change reproduction if needed, this is just at random
	for (female in matureFemales) {
		if (size(matureMales) > 0) {
			father = sample(matureMales, 1);
			nOffspring = sample(1:3, 1, replace=T, weights = c(0.2,0.2,0.6));
			for (i in seqLen(nOffspring)) {
				p3.addCrossed(female, father, sex=0.5);
			}}}}
	
	
	// Import pop for simulation
1 early () {
	sim.readFromPopulationFile("C:/Users/rosin/Desktop/popgen/source_pop_res/start_pop_simulation_snapshot_55601_r" + "burnin_id" + ".txt");}
	
////////////////////////////////////////////////////
//	4. Try to do fitnesss scaling for pops //////////////////
////////////////////////////////////////////////////


early() {
	for (s in sim.subpopulations) // but overwritten later for zoo, crater, ideally
	{
		inds = s.individuals; // not sure we need this anymore
		// skip empty subpops
		if (size(inds) == 0) {
			s.fitnessScaling = 1.0; // fallback
			continue;}
		
		// age and sex specific survival
		//0.01 for females, no info on males; 0.05 to be conservative
		L_F= c(0.5,0.2,0.05,0.05,0.15,0.15,0.15,0.15,0.15,0.15,0.4,0.4,0.4,0.4,1);
		L_M= c(0.5,0.4,0.2,0.2,0.3,0.3,0.3,0.3,0.3,0.3,0.4,0.4,0.4,0.4,1);
		
		ages = inds.age;
		//		mortality = L_F[ages];
		//		survival = 1 - mortality;
		//		inds.fitnessScaling = survival;
		
		m=(inds.sex=="M");
		f=(inds.sex=="F");
		
		ages_m = ages[m];
		ages_f = ages[f];
		
		mortality_m = L_M[ages_m];
		mortality_f = L_F[ages_f];
		
		//calculate survival based on age
		survival_m = 1 - mortality_m;
		survival_f = 1 - mortality_f;
		
		//rescale fitness based on age-survival
		inds[m].fitnessScaling = survival_m;
		inds[f].fitnessScaling = survival_f;
		
		p1.setValue("K", 2000);
		p2.setValue("K", KC_7);
		p3.setValue("K", 30);
		K = s.getValue("K");
		inds_m = s.individuals[m];
		inds_f = s.individuals[f];
		
		s.fitnessScaling = K/(s.individualCount * mean(c(survival_m, survival_f))); //works
		
		s.individuals.tagF = inds.fitnessScaling*s.fitnessScaling;
	}
}



early () {
	if (exists("p3")) {
		K_current = p3.getValue("K");
		N_current = max(p3.individualCount, 1); // avoid division by zero
		p3.fitnessScaling = 1.7 * K_current / N_current; // extra survival
	}}





// 4. Establish GSE -> Crater migration
//migration events //every 10 years - 0; 1; 5; 10
///////////////////////////////////

//~2031
55612 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2041
55622 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2051
55632 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2061
55642 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2071
55652 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2081
55662 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2091
55672 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2101
55682 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2111
55692 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}

//~2120
55702 late() {
	p1mig = p1.sampleIndividuals(M, sex="M", minAge=4);
	p2.takeMigrants(p1mig);
}






////////////////////////
// Logs and Stats ////
////////////////////////

1:55702 late() { //not sure what tick to put here
	if (sim.cycle % 100 == 0){
		print(sim.cycle);}}

// Create output for P1 
/////////////////////////////////

1 early() {
	HEAD = "Year,popSizeP1,PiP1,FitnessP1,meanHetP1,BP1,FROHP1,avgvStrDelP1,avgStrDelP1,avgModDelP1,avgWkDelP1,avgNeutP1,popSizeP2,PiP2,FitnessP2,meanHetP2,BP2,FROHP2,avgvStrDelP2,avgStrDelP2,avgModDelP2,avgWkDelP2,avgNeutP2,popSizeP3,PiP3,FitnessP3,meanHetP3,BP3,FROHP3,avgvStrDelP3,avgStrDelP3,avgModDelP3,avgWkDelP3,avgNeutP3, KCrater,Seed";
	writeFile(Out, HEAD, append=F);
}

// save source populations at present 
55702 late() {
	print("saving simulation");
	sim.outputFull("C:/Users/rosin/Desktop/popgen/Crater_GSE_forward/forward_GSE_Cr_pop_sim_55700_r" + "burnin_id" + "_" + "M" + "_" + "KC_7" + ".txt");}

//// record statistics every xx years

55603:55702 late() { //assuming a split 200 y BP 
	// change first number to whenever zoo pop was created !!
	if (sim.cycle % 2 == 0){
		stats1 = getStats(p1, sampleSize);
		stats2 = getStats(p2, sampleSize); // change sample size to N at the moment
		stats3 =getStats(p3, sampleSize);
		line=paste(c(sim.cycle + "," + size(p1.individuals) + "," + calcHeterozygosity(sample(p1.haplosomes,sampleSize)) + "," + stats1 + "," + size(p2.individuals) + "," + calcHeterozygosity(sample(p2.haplosomes,sampleSize)) + "," + stats2 + "," +size(p3.individuals) + "," + calcHeterozygosity(sample(p3.haplosomes,sampleSize)) + "," + stats3 + "," +  100 + "," + getSeed()));
		writeFile(Out,line,append=T);
	}
}

////////////////////////////
// functions /////////////
////////////////////////////
// define function to sample a population for
// mean fitness, heterozygosity, mean Froh,
// and avg num of mutations of different classes per individual (very str del, str del, mod del, wk del)
function (s) getStats(o pop, i sampSize)
{
	i = sample(pop.individuals, sampSize, F);
	i_serengeti = 100;
	i_crater = p2.individuals;
	i_zoo = p3.individuals;
	// i = pop.individuals
	// to try to sample all inds, made my slim freeze
	
	m = sortBy(i.haplosomes.mutations, "position"); //get all mutations in sample
	m_uniq = unique(m); // get rid of redundant muts
	DAF = sapply(m_uniq, "sum(m == applyValue);"); // count number of each mut in pop
	m_uniq_polym = m_uniq[DAF != i.haplosomes.size()]; //remove fixed mutations??
	
	//initialize vectors
	ROH_length_sumPerInd_10Mb = c();
	ROH_length_sumPerInd_1Mb = c();
	ROH_length_sumPerInd_500Kb = c();
	ROH_length_sumPerInd_100Kb = c();
	Num_vStrDel_muts = c();
	Num_strDel_muts = c();
	Num_modDel_muts = c();
	Num_wkDel_muts = c();
	Num_neut_muts = c();
	ind_het = c();
	B_pop = c();
	
	for (individual in i) {
		
		indm = sortBy(individual.haplosomes.mutations, "position");
		indm = indm[match(indm, m_uniq_polym) >= 0];   // Check that individual mutations are not fixed
		indm_uniq = unique(indm);
		
		genotype = sapply(indm_uniq, "sum(indm == applyValue);");
		
		// tally number of mutations for different classes of selection coefficient per individual
		s = individual.haplosomes.mutations.selectionCoeff;
		
		Num_vStrDel_muts = c(Num_vStrDel_muts, sum(s<=-0.1));
		Num_strDel_muts = c(Num_strDel_muts, sum(s<=-0.01));
		Num_modDel_muts = c(Num_modDel_muts, sum(s<=-0.001 & s > -0.01));
		Num_wkDel_muts = c(Num_wkDel_muts, sum(s<=-0.00001 & s > -0.001));
		Num_neut_muts = c(Num_neut_muts, sum(s==0.0));
		
		if (isNULL(genotype)) {
			ind_het = c(ind_het, 0); //putting this here to avoid error when trying to sum null vector
			next;
		}
		
		ind_het = c(ind_het, sum(genotype==1)/(seqLength));
		
		//code for getting ROHs
		
		ID_het = (genotype == 1); //outputs T/F for genotypes if they are het or homDer
		ID_homDer = (genotype == 2);
		pos_het = indm_uniq.position[ID_het]; //outputs positions of heterozgoys genotypes
		
		startpos = c(0, pos_het); //adds 0 to beggining of vector of hets
		endpos = c(pos_het, sim.chromosome.lastPosition); //adds last position in genome to vector of hets
		pos_het_diff = endpos - startpos;
		
		
		//sum for ROHs > 10Mb
		ROH_startpos_10Mb = startpos[pos_het_diff > 10000000]; //filter out startpos that dont correspond to ROH > 10Mb
		ROH_endpos_10Mb = endpos[pos_het_diff > 10000000];
		ROH_length_10Mb = pos_het_diff[pos_het_diff > 10000000]; //vector of ROHs for each individual
		ROH_length_sum_10Mb = sum(ROH_length_10Mb);
		ROH_length_sumPerInd_10Mb = c(ROH_length_sumPerInd_10Mb, ROH_length_sum_10Mb); // add sum of ROHs for each individual to vector of ROHs for all individuals
		
		//sum for ROHs > 1Mb
		ROH_startpos_1Mb = startpos[pos_het_diff > 1000000]; //filter out startpos that dont correspond to ROH > 1Mb
		ROH_endpos_1Mb = endpos[pos_het_diff > 1000000];
		ROH_length_1Mb = pos_het_diff[pos_het_diff > 1000000]; //vector of ROHs for each individual
		ROH_length_sum_1Mb = sum(ROH_length_1Mb);
		ROH_length_sumPerInd_1Mb = c(ROH_length_sumPerInd_1Mb, ROH_length_sum_1Mb); // add sum of ROHs for each individual to vector of ROHs for all individuals
		
		//sum for ROHs > 500kb
		ROH_startpos_500Kb = startpos[pos_het_diff > 500000]; //filter out startpos that dont correspond to ROH > 500 Kb
		ROH_endpos_500Kb = endpos[pos_het_diff > 500000];
		ROH_length_500Kb = pos_het_diff[pos_het_diff > 500000]; //vector of ROHs for each individual
		ROH_length_sum_500Kb = sum(ROH_length_500Kb);
		ROH_length_sumPerInd_500Kb = c(ROH_length_sumPerInd_500Kb, ROH_length_sum_500Kb); // add sum of ROHs for each individual to vector of ROHs for all individuals
		
		
		//sum for ROHs > 100kb
		ROH_startpos_100Kb = startpos[pos_het_diff > 100000]; //filter out startpos that dont correspond to ROH > 100 Kb
		ROH_endpos_100Kb = endpos[pos_het_diff > 100000];
		ROH_length_100Kb = pos_het_diff[pos_het_diff > 100000]; //vector of ROHs for each individual
		ROH_length_sum_100Kb = sum(ROH_length_100Kb);
		ROH_length_sumPerInd_100Kb = c(ROH_length_sumPerInd_100Kb, ROH_length_sum_100Kb); // add sum of ROHs for each individual to vector of ROHs for all individuals
		
		//calculate 2B (inbreeding load)
		del_muts = c(individual.haplosomes.mutationsOfType(m1),individual.haplosomes.mutationsOfType(m2),individual.haplosomes.mutationsOfType(m3),individual.haplosomes.mutationsOfType(m4),individual.haplosomes.
			mutationsOfType(m5));
		B_ind = c();
		
		if (del_muts.length()>0) {
			for(m in del_muts){
				//check if mut is heterozygous
				if(individual.haplosomes.mutationCountsInHaplosomes(m)==1){
					
					//protect against case where s < -1 (can happen with gamma DFE)
					s = max(m.selectionCoeff,-1.0);
					//difference in fitness between het and hom is s*(h-1) (1+sh -(1+s))
					B_ind = c(B_ind, s*(m.mutationType.dominanceCoeff-1));
					//catn(m.id + "," +  m.selectionCoeff + "," + m.selectionCoeff*(m.mutationType.dominanceCoeff-1));
				}
			}
			
			if(isNULL(B_ind)){
				B_pop = c(B_pop, 0.0);
			}
			// this is summed rather than multiplied
			//even if fitness is multiplicative
			else{
				B_pop = c(B_pop, sum(B_ind));
			}
		
		}
	
	}
	
	
	return(mean(pop.cachedFitness(NULL)/pop.individuals.tagF) + "," + mean(ind_het) + ","  + mean(B_pop) + "," + mean(ROH_length_sumPerInd_100Kb)/seqLength + "," + mean(Num_vStrDel_muts) + "," + mean(Num_strDel_muts)+ "," + mean(Num_modDel_muts) + "," + mean(Num_wkDel_muts) + "," + mean(Num_neut_muts));

}

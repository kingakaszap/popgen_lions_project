////////////////////////////////////////////////////
//	1. Initialise everything //////////////////
//////////////////////////////////////////////////// 
initialize() {
	if (exists("slimgui")) {
		// Carrying capacities
		defineConstant("KGSE_3", 5000);
		defineConstant("KGSE_4", 5000);
		defineConstant("KGSE_6", 2000);
		
		defineConstant("KC_0", 100);
		defineConstant("KC_1", 80);
		defineConstant("KC_2", 15);
		defineConstant("KC_2a", 30);
		defineConstant("KC_3", 50);
		defineConstant("KC_4", 100);
		defineConstant("KC_5", 120);
		defineConstant("KC_6", 50);
		defineConstant("KC_7", 100);
		
		defineConstant("M", 0);
	}
	
	initializeSLiMModelType("nonWF");
	initializeSex("A");
	defineConstant("geneLength", 1750);
	initializeMutationRate(5e-9);
	
	// Dominance coefficients
	defineConstant("h_VstrDel", 0.0);
	defineConstant("h_strDel", 0.01);
	defineConstant("h_modDel", 0.1);
	defineConstant("h_wkDel", 0.4);
	defineConstant("sampleSize", 10);
	// change this later to sample whole crater pop for statistics
	defineConstant("Out", "C:/Users/Kinga/OneDrive - University of Edinburgh/Desktop/popgen/" + "new_populations" + "M=" + M + "_KF=" + KC_7 + "_" + getSeed() + ".csv");
	
	// dont forget to change this to my own filepath
	
	// Mutation types
	initializeMutationType("m1", h_VstrDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x >= -0.1); return x;");
	m1.convertToSubstitution = F;
	initializeMutationType("m2", h_strDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.1 | x >= -0.01); return x;");
	m2.convertToSubstitution = F;
	initializeMutationType("m3", h_modDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.01 | x >= -0.001); return x;");
	m3.convertToSubstitution = F;
	initializeMutationType("m4", h_wkDel, "s", "do x=rgamma(1,-0.01314833,0.186); while (x < -0.001); return x;");
	m4.convertToSubstitution = F;
	initializeMutationType("m5", 0.0,"f",-1.0);
	m5.convertToSubstitution = F;
	initializeMutationType("m6", 0.5,"f",0.0);
	m6.convertToSubstitution = T;
	
	// Genomic elements
	initializeGenomicElementType("g1", c(m1,m2,m3,m4,m5,m6), c(2.6,23.6,24.7,49.1,0.5,43.3));
	gene_vec = c(500,500,500,500,500,500,500,500,500,500);
	defineConstant("seqLength", sum(gene_vec)*geneLength);
	gene_num = sum(gene_vec);
	
	for (i in 1:gene_num) {
		initializeGenomicElement(g1, ((i-1)*geneLength)+(i-1), (i*geneLength)+(i-2));}
	
	// Recombination rates
	rates = NULL;
	for (i in 1:(size(gene_vec)-1)) {
		rates = c(rates, 0, rep(c(1e-3,0), asInteger(gene_vec[i-1]-1)), 0.5);}
	rates = c(rates, 0, rep(c(1e-3,0), asInteger(gene_vec[size(gene_vec)-1]-1)));
	
	ends = NULL;
	for (i in 1:gene_num) {
		ends = c(ends, (i*geneLength)+(i-2), (i*geneLength)+(i-1));}
	ends = ends[0:(size(ends)-2)];
	
	initializeRecombinationRate(rates, ends);}

////////////////////////////////////////////////////
//	2. Import burnin population //////////////////
////////////////////////////////////////////////////
1 early() {
	sim.readFromPopulationFile("C:\\Users\\Kinga\\OneDrive - University of Edinburgh\\Desktop\\popgen\\Source_pop_simulation_snapshot_55400_r1.txt");}
	// ends at 55400 - move everything back by 200 years

////////////////////////////////////////////////////
//	3. reproduction for GSE //////////////////
////////////////////////////////////////////////////

reproduction(p1) {
	if (sim.cycle % 2 == 0){ //reproduction every 2 years - seems to reduce poppulation size by a lot
		// get males and females and randomize their order
		matureMales = subpop.sampleIndividuals(asInteger(sum(subpop.individuals.sex == "M")*0.69), sex="M", minAge=4,maxAge=10);
		matureMales_mating_twice=sample(matureMales,asInteger(length(matureMales)*0.6));
		males=c(matureMales,matureMales_mating_twice);
		//males = sample(males, size(males), replace=F);
		//cat(sim.cycle + "," + "males=" + size(males)+ "\n");
		
		females = subpop.subsetIndividuals(sex="F", minAge=3,maxAge=14);
		females = sample(females, size(females), replace=F);
		//cat(sim.cycle + "," + "females=" + size(males)+ "\n");
		
		femaleCount = size(females);
		// draw number of offspring for males, assuming dominance
		offspringCounts = sample(1:3, size(males), replace=T, weights=c(0.2,0.2,0.6));
		// go through the males until we run out of females
		nextFemaleIndex = 0;
		males.tag = 0;
		for (maleIndex in seqAlong(males))
		{
			male = males[maleIndex];
			offspringCount = offspringCounts[maleIndex];
			
			//catn("male offspring number: " + paste(males.tag));
			for (i in seqLen(offspringCount))
			{
				if (nextFemaleIndex < femaleCount)
				{
					offspring = subpop.addCrossed(females[nextFemaleIndex], male,sex = 0.5);
					nextFemaleIndex = nextFemaleIndex + 1;
					male.tag = male.tag + 1;
				}
				else
				{
					// disable this callback for this cycle
					self.active = 0;
					return;
				}}}}
	// disable this callback for this cycle
	self.active = 0;}
	
////////////////////////////////////////////////////
//	4. Try to do fitnesss scaling for pops //////////////////
////////////////////////////////////////////////////

early() {
	for (s in sim.subpopulations) // but overwritten later for zoo, crater, ideally
	{
		inds = s.individuals; // not sure we need this anymore
		// skip empty subpops
		if (size(inds) == 0) {
			s.fitnessScaling = 1.0; // fallback
			continue;}
		
		// age and sex specific survival
		//0.01 for females, no info on males; 0.05 to be conservative
		L_F= c(0.5,0.2,0.05,0.05,0.15,0.15,0.15,0.15,0.15,0.15,0.4,0.4,0.4,0.4,1);
		L_M= c(0.5,0.4,0.2,0.2,0.3,0.3,0.3,0.3,0.3,0.3,0.4,0.4,0.4,0.4,1);
		
		ages = inds.age;
		//		mortality = L_F[ages];
		//		survival = 1 - mortality;
		//		inds.fitnessScaling = survival;
		
		m=(inds.sex=="M");
		f=(inds.sex=="F");
		
		ages_m = ages[m];
		ages_f = ages[f];
		
		mortality_m = L_M[ages_m];
		mortality_f = L_F[ages_f];
		
		//calculate survival based on age
		survival_m = 1 - mortality_m;
		survival_f = 1 - mortality_f;
		
		//rescale fitness based on age-survival
		inds[m].fitnessScaling = survival_m;
		inds[f].fitnessScaling = survival_f;
		
		p1.setValue("K", 2000);
		K = s.getValue("K");
		inds_m = s.individuals[m];
		inds_f = s.individuals[f];
		
		s.fitnessScaling = K /(s.individualCount * mean(c(survival_m, survival_f))); //works
		
		s.individuals.tagF = inds.fitnessScaling*s.fitnessScaling;
	}
}

////////////////////////////////////////////////////
//	5. Make crater pop  events //////////////////
////////////////////////////////////////////////////
55401 late() { // should correspond to  1820
	sim.addSubpop("p2", 0).setValue("K", 100);
	migrants_F = p1.sampleIndividuals(50, sex="F", minAge=2, maxAge=10);
	migrants_M = p1.sampleIndividuals(50, sex="M", minAge=2, maxAge=10);
	p2.takeMigrants(c(migrants_F, migrants_M));
	print("cycle number:" + sim.cycle + " Crater pop. created");}

// Crater K updates -- ajust based on when burnin ends
55531 late() { p2.setValue("K", KC_1); catn("Crater 1950: " + p2.individualCount); }
55543 late() { p2.setValue("K", KC_2); catn("Crater 1962: " + p2.individualCount); }
55545 late() { p2.takeMigrants(p1.sampleIndividuals(4, sex="M", minAge=4, maxAge=10)); }
55546 late() { p2.setValue("K", KC_2a); p2.takeMigrants(p1.sampleIndividuals(3, sex="M", minAge=4, maxAge=10)); }
55549 late() { p2.setValue("K", KC_3); }
55560 late() { p2.setValue("K", KC_4); catn("Crater 1979: " + p2.individualCount); }
55562 late() { p2.setValue("K", KC_5); catn("Crater 1981: " + p2.individualCount); }
55574 late() { p2.takeMigrants(p1.sampleIndividuals(1, sex="M", minAge=4, maxAge=10)); catn("Crater 1993: " + p2.individualCount); }
55581 late() { p2.setValue("K", KC_6); catn("Crater 2000: " + p2.individualCount); }
55594 late() { p2.takeMigrants(p1.sampleIndividuals(4, sex="M", minAge=4, maxAge=10)); catn("Crater 2013: " + p2.individualCount); }
55596 late() { p2.takeMigrants(p1.sampleIndividuals(1, sex="M", minAge=4, maxAge=10)); }
55599 late() { p2.takeMigrants(p1.sampleIndividuals(2, sex="M", minAge=4, maxAge=10)); }
55601 late() { p2.setValue("K", 60); } // changed to keep around 60 for 2020
55602 late() { p2.setValue("K", KC_7); catn("Crater 2021: " + p2.individualCount); }

////////////////////////////////////////////////////
//	5. reproduction for crater //////////////////
////////////////////////////////////////////////////
reproduction(p2) {
	if (sim.cycle % 2 == 0){
		// get males and females and randomize their order
		matureMales = subpop.sampleIndividuals(asInteger(sum(subpop.individuals.sex == "M")*0.78), sex="M", minAge=4,maxAge=10);
		matureMales_mating_twice=sample(matureMales,asInteger(length(matureMales)*0.6));
		migrantMales = subpop.sampleIndividuals(subpop.individuals.size(), sex="M", minAge=2,maxAge=9,migrant=T);
		males=c(matureMales,matureMales_mating_twice,migrantMales);
		//cat(sim.cycle + "," + "males=" + size(males)+ "\n");
		
		matureFemales = subpop.subsetIndividuals(sex="F", minAge=3,maxAge=14);
		females=c(matureFemales);
		//cat(sim.cycle + "," + "females=" + size(males)+ "\n");
		
		femaleCount = size(females);
		// draw number of offspring for males, assuming dominance
		offspringCounts = sample(1:3, size(males), replace=T, weights=c(0.2,0.2,0.6));
		// go through the males until we run out of females
		nextFemaleIndex = 0;
		males.tag = 0;
		for (maleIndex in seqAlong(males))
		{
			male = males[maleIndex];
			offspringCount = offspringCounts[maleIndex];
			
			//catn("male offspring number: " + paste(males.tag));
			//seems like it assumes that a female produces 1 offspring (it loops over offspringcount)
			for (i in seqLen(offspringCount))
			{
				if (nextFemaleIndex < femaleCount)
				{
					offspring = subpop.addCrossed(females[nextFemaleIndex], male,sex = 0.5);
					nextFemaleIndex = nextFemaleIndex + 1;
					male.tag = male.tag + 1;
				}
				else
				{
					// disable this callback for this cycle
					self.active = 0;
					return;
				}}}}
	// disable this callback for this cycle
	self.active = 0;}


////////////////////////////////////////////////////
//	7. Zoo population with high fitness scaling //////////////////
////////////////////////////////////////////////////
55551 late() { //  55501 to make pop in 1920
// currently making it in 1970 to reduce froh --- forgot what time was the ideal
// how else to reduce it, apart from making pop later? migrants?
	sim.addSubpop("p3", 0).setValue("K", 30);
	// can adjust sex ratio and n migrants if needed
	migrants_F_zoo = p1.sampleIndividuals(5, sex="F", minAge=2);
	migrants_M_zoo = p1.sampleIndividuals(5, sex="M", minAge=2);
	p3.takeMigrants(c(migrants_F_zoo, migrants_M_zoo));
	print("cycle number:" + sim.cycle + " zoo population created");
	catn("zoo 1990: " + p3.individualCount); //double check
}
55591 late() { p3.takeMigrants(p1.sampleIndividuals(2, sex="F", minAge=4, maxAge=10)); }
55692 late() { p3.takeMigrants(p1.sampleIndividuals(2, sex="M", minAge=4, maxAge=10)); }


// fitness scaling so its hard to die in the zoo
early() {
	if (exists("p3")) {
		K_current = p3.getValue("K"); 
		N_current = max(p3.individualCount, 1); // avoid division by zero
		p3.fitnessScaling = 1.7 * K_current / N_current; // extra survival
	}}

// reproduction in zoo
reproduction(p3) {
	matureFemales = p3.subsetIndividuals(sex="F", minAge=2, maxAge=15);
	matureMales   = p3.subsetIndividuals(sex="M", minAge=2, maxAge=15);
	
	// can change reproduction if needed, this is just at random
	for (female in matureFemales) {
		if (size(matureMales) > 0) {
			father = sample(matureMales, 1);
			nOffspring = sample(1:3, 1, replace=T, weights = c(0.2,0.2,0.6));
			for (i in seqLen(nOffspring)) {
				p3.addCrossed(female, father, sex=0.5);
			}}}}

////////////////////////
// Logs and Stats ////
////////////////////////

1:55602 late() { //not sure what tick to put here
if (sim.cycle % 100 == 0){
	print(sim.cycle);}}

// Create output for P1 
/////////////////////////////////

1 early() {
    HEAD = "Year,popSizeP1,PiP1,FitnessP1,meanHetP1,BP1,FROHP1,avgvStrDelP1,avgStrDelP1,avgModDelP1,avgWkDelP1,avgNeutP1,popSizeP2,PiP2,FitnessP2,meanHetP2,BP2,FROHP2,avgvStrDelP2,avgStrDelP2,avgModDelP2,avgWkDelP2,avgNeutP2,popSizeP3,PiP3,FitnessP3,meanHetP3,BP3,FROHP3,avgvStrDelP3,avgStrDelP3,avgModDelP3,avgWkDelP3,avgNeutP3, KCrater,Seed";
    writeFile(Out, HEAD, append=F);
}



//// record statistics every xx years

55551:55602 late() { //assuming a split 200 y BP 
// change first number to whenever zoo pop was created !!
	if (sim.cycle % 2 == 0){
		stats1 = getStats(p1, sampleSize);
		stats2 = getStats(p2, sampleSize); // change sample size to N at the moment
		stats3 =getStats(p3, sampleSize);
		line=paste(c(sim.cycle + "," + size(p1.individuals) + "," + calcHeterozygosity(sample(p1.haplosomes,sampleSize)) + "," + stats1 + "," + size(p2.individuals) + "," + calcHeterozygosity(sample(p2.haplosomes,sampleSize)) + "," + stats2 + "," +size(p3.individuals) + "," + calcHeterozygosity(sample(p3.haplosomes,sampleSize)) + "," + stats3 + "," +  KC_7 + "," + getSeed()));
		writeFile(Out,line,append=T);
	}
}

////////////////////////////
// functions /////////////
////////////////////////////
// define function to sample a population for
// mean fitness, heterozygosity, mean Froh,
// and avg num of mutations of different classes per individual (very str del, str del, mod del, wk del)
function (s) getStats(o pop, i sampSize)
{
	i = sample(pop.individuals, sampSize, F);

    // i = pop.individuals
	// to try to sample all inds, made my slim freeze

	m = sortBy(i.haplosomes.mutations, "position"); //get all mutations in sample
	m_uniq = unique(m); // get rid of redundant muts
	DAF = sapply(m_uniq, "sum(m == applyValue);"); // count number of each mut in pop
	m_uniq_polym = m_uniq[DAF != i.haplosomes.size()]; //remove fixed mutations??

	//initialize vectors
	ROH_length_sumPerInd_10Mb = c();
	ROH_length_sumPerInd_1Mb = c();
	ROH_length_sumPerInd_500Kb = c();
	ROH_length_sumPerInd_100Kb = c();
	Num_vStrDel_muts = c();
	Num_strDel_muts = c();
	Num_modDel_muts = c();
	Num_wkDel_muts = c();
	Num_neut_muts = c();
	ind_het = c();
	B_pop = c();

	for (individual in i) {

		indm = sortBy(individual.haplosomes.mutations, "position");
		indm = indm[match(indm, m_uniq_polym) >= 0];   // Check that individual mutations are not fixed
		indm_uniq = unique(indm);

		genotype = sapply(indm_uniq, "sum(indm == applyValue);");

		// tally number of mutations for different classes of selection coefficient per individual
		s = individual.haplosomes.mutations.selectionCoeff;

		Num_vStrDel_muts = c(Num_vStrDel_muts, sum(s<=-0.1));
		Num_strDel_muts = c(Num_strDel_muts, sum(s<=-0.01));
		Num_modDel_muts = c(Num_modDel_muts, sum(s<=-0.001 & s > -0.01));
		Num_wkDel_muts = c(Num_wkDel_muts, sum(s<=-0.00001 & s > -0.001));
		Num_neut_muts = c(Num_neut_muts, sum(s==0.0));

		if (isNULL(genotype)) {
			ind_het = c(ind_het, 0); //putting this here to avoid error when trying to sum null vector
			next;
		}

		ind_het = c(ind_het, sum(genotype==1)/(seqLength));

		//code for getting ROHs

		ID_het = (genotype == 1); //outputs T/F for genotypes if they are het or homDer
		ID_homDer = (genotype == 2);
		pos_het = indm_uniq.position[ID_het]; //outputs positions of heterozgoys genotypes

		startpos = c(0, pos_het); //adds 0 to beggining of vector of hets
		endpos = c(pos_het, sim.chromosome.lastPosition); //adds last position in genome to vector of hets
		pos_het_diff = endpos - startpos;


		//sum for ROHs > 10Mb
		ROH_startpos_10Mb = startpos[pos_het_diff > 10000000]; //filter out startpos that dont correspond to ROH > 10Mb
		ROH_endpos_10Mb = endpos[pos_het_diff > 10000000];
		ROH_length_10Mb = pos_het_diff[pos_het_diff > 10000000]; //vector of ROHs for each individual
		ROH_length_sum_10Mb = sum(ROH_length_10Mb);
		ROH_length_sumPerInd_10Mb = c(ROH_length_sumPerInd_10Mb, ROH_length_sum_10Mb); // add sum of ROHs for each individual to vector of ROHs for all individuals

		//sum for ROHs > 1Mb
		ROH_startpos_1Mb = startpos[pos_het_diff > 1000000]; //filter out startpos that dont correspond to ROH > 1Mb
		ROH_endpos_1Mb = endpos[pos_het_diff > 1000000];
		ROH_length_1Mb = pos_het_diff[pos_het_diff > 1000000]; //vector of ROHs for each individual
		ROH_length_sum_1Mb = sum(ROH_length_1Mb);
		ROH_length_sumPerInd_1Mb = c(ROH_length_sumPerInd_1Mb, ROH_length_sum_1Mb); // add sum of ROHs for each individual to vector of ROHs for all individuals

		//sum for ROHs > 500kb
		ROH_startpos_500Kb = startpos[pos_het_diff > 500000]; //filter out startpos that dont correspond to ROH > 500 Kb
		ROH_endpos_500Kb = endpos[pos_het_diff > 500000];
		ROH_length_500Kb = pos_het_diff[pos_het_diff > 500000]; //vector of ROHs for each individual
		ROH_length_sum_500Kb = sum(ROH_length_500Kb);
		ROH_length_sumPerInd_500Kb = c(ROH_length_sumPerInd_500Kb, ROH_length_sum_500Kb); // add sum of ROHs for each individual to vector of ROHs for all individuals


		//sum for ROHs > 100kb
		ROH_startpos_100Kb = startpos[pos_het_diff > 100000]; //filter out startpos that dont correspond to ROH > 100 Kb
		ROH_endpos_100Kb = endpos[pos_het_diff > 100000];
		ROH_length_100Kb = pos_het_diff[pos_het_diff > 100000]; //vector of ROHs for each individual
		ROH_length_sum_100Kb = sum(ROH_length_100Kb);
		ROH_length_sumPerInd_100Kb = c(ROH_length_sumPerInd_100Kb, ROH_length_sum_100Kb); // add sum of ROHs for each individual to vector of ROHs for all individuals

		//calculate 2B (inbreeding load)
		del_muts = c(individual.haplosomes.mutationsOfType(m1),individual.haplosomes.mutationsOfType(m2),individual.haplosomes.mutationsOfType(m3),individual.haplosomes.mutationsOfType(m4),individual.haplosomes.
mutationsOfType(m5));
		B_ind = c();

		if (del_muts.length()>0) {
			for(m in del_muts){
				//check if mut is heterozygous
				if(individual.haplosomes.mutationCountsInHaplosomes(m)==1){

					//protect against case where s < -1 (can happen with gamma DFE)
					s = max(m.selectionCoeff,-1.0);
					//difference in fitness between het and hom is s*(h-1) (1+sh -(1+s))
					B_ind = c(B_ind, s*(m.mutationType.dominanceCoeff-1));
					//catn(m.id + "," +  m.selectionCoeff + "," + m.selectionCoeff*(m.mutationType.dominanceCoeff-1));
				}
			}

			if(isNULL(B_ind)){
				B_pop = c(B_pop, 0.0);
			}
			// this is summed rather than multiplied
			//even if fitness is multiplicative
			else{
				B_pop = c(B_pop, sum(B_ind));
			}

		}

	}


	return(mean(pop.cachedFitness(NULL)/pop.individuals.tagF)+ "," + mean(ind_het) + ","  + mean(B_pop) + "," + mean(ROH_length_sumPerInd_100Kb)/seqLength + "," + mean(Num_vStrDel_muts) + "," + mean(Num_strDel_muts)+ "," + mean(Num_modDel_muts) + "," + mean(Num_wkDel_muts) + "," + mean(Num_neut_muts));

}
